# <b style="margin-left:300px">## DATE</b>## 

![](./IMG/images.png)

## Объекты JavaScript Dateпредставляют отдельный момент времени в независимом от платформы формате. Dateобъекты инкапсулируют целое число, которое представляет миллисекунды с полуночи начала 1 января 1970 года по всемирному координированному времени (эпоха ) .

# Описание

## Эпоха, временные метки и неверная дата. Дата в JavaScript обычно определяется как время в миллисекундах, прошедшее с эпохи , которая определяется как полночь в начале 1 января 1970 года по всемирному координированному времени (эквивалент эпохи UNIX ). Эта временная метка не зависит от часового пояса и однозначно определяет момент в истории.

## Максимальная временная метка, которую представляет Dateобъект, немного меньше максимального безопасного целого числа ( Number.MAX_SAFE_INTEGER9 007 199 254 740 991). Объект Dateможет представлять максимум ±8 640 000 000 000 000 миллисекунд или ± 100 000 000 (сто миллионов) дней относительно эпохи. Это диапазон с 20 апреля 271821 г. до н.э. по 13 сентября 275760 г. н.э. Любая попытка представить время за пределами этого диапазона приводит к тому, что Dateобъект содержит значение метки времени NaN, которое является «Недопустимой датой».

## Существуют различные методы, позволяющие взаимодействовать с отметкой времени, хранящейся в дате:

## Вы можете напрямую взаимодействовать со значением метки времени, используя методы getTime()и setTime().

## Методы valueOf()and [@@toPrimitive]()(при их передаче "number"), которые автоматически вызываются при приведении чисел , возвращают метку времени, заставляя Dateобъекты вести себя так же, как их метки времени, при использовании в числовых контекстах.

## Все статические методы ( Date.now(), Date.parse()и Date.UTC()) возвращают метки времени вместо Dateобъектов.

## Конструктор Date()можно вызвать с меткой времени в качестве единственного аргумента.

# Kомпоненты даты и часовые пояса

## Дата внутренне представляется как одно число, метка времени . При взаимодействии с ним временную метку необходимо интерпретировать как структурированное представление даты и времени. Всегда есть два способа интерпретировать временную метку: как местное время или как всемирное координированное время (UTC), глобальное стандартное время, определенное мировым стандартом времени. Местный часовой пояс не хранится в объекте даты, но определяется средой хоста (устройством пользователя).

## Конструктор Date()можно вызвать с двумя или более аргументами, и в этом случае они интерпретируются как год, месяц, день, час, минута, секунда и миллисекунда соответственно по местному времени. Date.UTC()работает аналогично, но интерпретирует компоненты как время UTC, а также принимает один аргумент, представляющий год.

## Примечание. Некоторые методы, включая Date()конструктор Date.UTC()и устаревшие методы getYear()/ setYear(), интерпретируют двузначный год как год 1900-х годов. Например, new Date(99, 5, 24)интерпретируется как 24 июня 1999 г., а не 24 июня 99 г. Для получения дополнительной информации см. Интерпретацию двузначных годов .

## Когда сегмент выходит за пределы или занижает ожидаемый диапазон, он обычно «переносится в» или «заимствует» из более высокого сегмента. Например, если для месяца установлено значение 12 (месяцы отсчитываются от нуля, поэтому декабрь равен 11), он становится январём следующего года. Если день месяца установлен на 0, он становится последним днем ​​предыдущего месяца. Это также относится к датам, указанным в формате строки даты и времени .

# Формат строки даты и времени

## Существует множество способов форматирования даты в виде строки. Спецификация JavaScript определяет только один формат, который должен поддерживаться повсеместно: формат строки даты и времени , упрощение расширенного формата даты календаря ISO 8601. Формат следующий:

## YYYY— это год, состоящий из четырех цифр ( 0000до 9999) или в виде расширенного года+ , -за которым следуют шесть цифр. Знак требуется для расширенных лет. -000000явно запрещен в качестве действительного года.

## MM— месяц, состоящий из двух цифр ( 01до 12). По умолчанию 01.

## DD— день месяца, состоящий из двух цифр ( 01до 31). По умолчанию 01.

## T— буквальный символ, указывающий начало временной части строки. Требуется Tпри указании временной части.

## HHэто час, состоящий из двух цифр ( 00до 23). В особом случае 24:00:00это разрешено и интерпретируется как полночь в начале следующего дня. По умолчанию 00.

## mm— минуты, состоящие из двух цифр ( 00до 59). По умолчанию 00.

## ssвторой, с двумя цифрами ( 00до 59). По умолчанию 00.

## sss— миллисекунда, состоящая из трех цифр ( 000до 999). По умолчанию 000.

## Z— это смещение часового пояса, которое может быть либо буквальным символом Z(указывающим UTC), либо +смещением в часах и минутах от UTC, -за которым следует .HH:mm

## Например, "2011-10-10"( форма только для даты"2011-10-10T14:48:00" ), ( форма даты и времени ) или "2011-10-10T14:48:00.000+09:00"( форма даты и времени с миллисекундами и часовым поясом) — все это допустимые строки даты и времени.

## Если смещение часового пояса отсутствует, формы, содержащие только дату, интерпретируются как время UTC, а формы даты и времени интерпретируются как местное время. Это связано с исторической ошибкой спецификации, которая не соответствовала стандарту ISO 8601, но не могла быть изменена из-за веб-совместимости. См. раздел «Неисправный парсер — проблема веб-реальности» .

## Date.parse()и Date()конструктор принимает в качестве входных данных строки в формате строки даты и времени. Более того, реализациям разрешено поддерживать другие форматы дат, если входные данные не соответствуют этому формату.

## Метод toISOString()возвращает строковое представление даты в формате строки даты и времени со смещением часового пояса, всегда установленным в Z(UTC).

## Примечание. Для максимальной совместимости рекомендуется убедиться, что введенные вами данные соответствуют формату строки даты и времени, указанному выше, поскольку поддержка других форматов не гарантируется. Однако есть некоторые форматы, которые поддерживаются во всех основных реализациях, например формат RFC 2822 , и в этом случае их использование может быть приемлемым. Всегда проводите кроссбраузерные тесты , чтобы убедиться, что ваш код работает во всех целевых браузерах. Библиотека может помочь, если необходимо поддерживать множество различных форматов.

## Нестандартные строки могут анализироваться любым способом по желанию реализации, включая часовой пояс — большинство реализаций по умолчанию используют локальный часовой пояс. Реализации не обязаны возвращать недопустимую дату для компонентов даты за пределами границ, хотя обычно они это делают. Строка может иметь компоненты даты в границах (с границами, определенными выше), но в действительности не представляет дату (например, «30 февраля»). В этом случае реализации ведут себя непоследовательно. На Date.parse()странице представлены дополнительные примеры таких нестандартных случаев.

## Другие способы форматирования даты

## toISOString()возвращает строку в формате 1970-01-01T00:00:00.000Z(формат строки даты и времени, представленный выше и упрощенный ISO 8601 ). toJSON()вызывает toISOString()и возвращает результат.

## toString()возвращает строку в формате Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time)while toDateString()и toTimeString()возвращает части строки с датой и временем соответственно. [@@toPrimitive]()(при передаче "string"или "default") вызывает toString()и возвращает результат.

## toUTCString()возвращает строку в формате Thu, 01 Jan 1970 00:00:00 GMT(обобщенный RFC 7231 ).

## toLocaleDateString(), toLocaleTimeString()и toLocaleString()использовать форматы даты и времени, зависящие от локали, обычно предоставляемые IntlAPI.

>##  const date = new Date("2000-01-17T16:45:30");
>##  const [month, day, year] = [
>##   date.getMonth(),
>##   date.getDate(),
>##   date.getFullYear(),
>## ];
>## // [0, 17, 2000] as month are 0-indexed
>## const [hour, minutes, seconds] = [
>##   date.getHours(),
>##   date.getMinutes(),
>##   date.getSeconds(),
>## ];
>## // [16, 45, 30]

# Интерпретация двузначных годов
## new Date()демонстрирует устаревшее нежелательное, непоследовательное поведение с двузначными значениями года; в частности, когда new Date()вызову присваивается двузначное значение года, это значение года не рассматривается как буквальный год и не используется как есть, а вместо этого интерпретируется как относительное смещение — в некоторых случаях как смещение от года 1900, но в других случаях в качестве компенсации за год 2000.

>## let date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
>## date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)
>## date = new Date("2/1/22"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT)
>## // Legacy method; always interprets two-digit year values as relative to 1900
>## date.setYear(98);
>## date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)
>## date.setYear(22);
>## date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT)